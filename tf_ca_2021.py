# -*- coding: utf-8 -*-
"""TF_CA_2021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gW6dodJ5OO85guAEUZ4RmwNrfcK6Yrpz
"""

!git clone https://github.com/lmcanavals/algorithmic_complexity.git

import pandas as pd
import networkx as nx
from algorithmic_complexity.aclib import graphstuff as gs
import numpy as np
import heapq as hq 
import math

url='https://raw.githubusercontent.com/draul99/traveling_data/main/data.csv'

def haversine(cp1, cp2):
  la1, lo1 = float(cp1['LATITUD']), float(cp1['LONGITUD'])
  la2, lo2 = float(cp2['LATITUD']), float(cp2['LONGITUD'])
  
  lo1, la1, lo2, la2 = map(math.radians, [lo1, la1, lo2, la2])
  dlo = lo2 - lo1
  dla = la2 - la1
  a = math.sin(dla/2)**2 + math.cos(la1) * math.cos(la2) * math.sin(dlo/2)**2
  c = 2 * math.asin(math.sqrt(a))
  r = 6371

  return round(c * r, 2)

df=pd.read_csv(url) #lectura de nuestro archivo de datos al que llamamos df
pd.set_option('display.max_rows',None) #El None es para desplegar todos los datos.
df

nomprovincias = df['PROVINCIA'].unique() #Obtenemos todas las provincias disponibles
print('Podemos encontrar un total de',len(nomprovincias),'provincias')
print(nomprovincias)

provincias = dict()
print('Cantidad de centros poblados que hay en cada provincia\n')
for nom in nomprovincias:
  provincias[nom] = df[df['PROVINCIA'] == nom]
  print(nom, len(provincias[nom]))

"""SELECCIÓN DE PROVINCIA"""

#@title Provincia 
#@markdown Ingrese la provincia

no_type_checking = ''
nom_prov = 'BONGARA' #@param {type:"string"}

nomdistritos = provincias[nom_prov]['DISTRITO'].unique()
print('Los distritos pertenecientes a la provincia de',nom_prov, 'son los siguientes',len(nomdistritos))
print(nomdistritos)

distritos=dict() #Cantidad de centros poblados por distrito
for nom in nomdistritos:
  distritos[nom]=provincias[nom_prov][provincias[nom_prov]['DISTRITO']==nom]
  print(nom,len(distritos[nom]))

"""CENTROS POBLADOS DE 1 DISTRITO EN ESPECÍFICO"""

#@title Distrito 
#@markdown Ingrese el distrito

no_type_checking = ''
nom_dist = 'JAZAN' #@param {type:"string"}

distrito = distritos[nom_dist]
G = nx.Graph()
col = 'CENTRO POBLADO'
index = distrito.index[0]
for i, cp1 in distrito.iterrows():
    G.add_node(i-index, label=cp1[col])
for i, cp1 in distrito.iterrows():
    for j, cp2 in distrito.iterrows():
        if cp1[col] != cp2[col]: #and dist(cp1, cp2) < 0.006:
            G.add_edge(i-index, j-index, weight=haversine(cp1, cp2))

#print(ind1, ind2)

"""GRÁFICO DE LOS CENTROS POBLADOS EN 1 DISTRITO CON SU RESPECTIVO LABEL"""

gs.nx2gv(G, nodeinfo = True, weighted=True, params={'size':'20'})

"""1.   DIJKSTRA"""

def dijkstra(G, s):
  for u in G.nodes:
    G.nodes[u]['visited'] = False             #Inicializamos los nodos como no visitados
    G.nodes[u]['path']    = -1                #Asignamos a los predecesores como desconocidos
    G.nodes[u]['cost']    = math.inf          #Asignamos como infinito al costo para llegar a cada vertice
    
  G.nodes[s]['cost'] = 0                      #Inicializamos el costo del vertice source como 0
  q = [(0, s)]                                #Agregamos el vertice source a la cola de prioridad teniendo en cuenta el costo
  while q:
    g_u, u = hq.heappop(q)                    #Retiramos un elemento de la cola y obtenemos el peso del vertice y el vertice
    if not G.nodes[u]['visited']:             #De no haber sido visitado el vertice lo marcamos como tal
      G.nodes[u]['visited'] = True
      for v in G.neighbors(u):                #Para cada vecino del vertice u
        if not G.nodes[v]['visited']:         #Si el vertice v no ha sido visitado 
          w_uv = G.edges[u, v]['weight']      #Recuperamos el peso de la arista u_v
          f_v  = g_u + w_uv                   #Calculamos el costo de llegar a v a traves de u
          g_v  = G.nodes[v]['cost']           #Recuperamos del grafo el costo actual para llegar a v
          if f_v < g_v:                       #Si la nueva distancia es menor a la distancia conocida hemos encontrado un camino mas rapido
            G.nodes[v]['cost'] = f_v          #Actualizamos el nodo vecino con el nuevo costo 
            G.nodes[v]['path'] = u            #Consideramos el antecesor de v como u
            hq.heappush(q, (f_v, v))          #Agregamos v con su nuevo costo a la cola de prioridad
 
 
  path = [0]*G.number_of_nodes()              #Extraemos el path de todos los vertices y lo almacenamos en un arreglo
  for v, info in G.nodes.data():
    path[v] = info['path']

  return path

"""PATH CON DIJKSTRA"""

path = dijkstra(G, 1)
gs.nx2gv(G, path=path, weighted=True, params={'size':'20'})

"""2.   DFS"""

def _dfs(G, u, cam, sig):
    min = math.inf
    if not G.nodes[u]['visited']:
        G.nodes[u]['visited'] = True
        cam.append(u)
        for v in G.neighbors(u):
            for edge in G.edges(u):
                if v == edge[1] and G.edges[u, v]['weight'] < min and not G.nodes[v]['visited']:
                    min = G.edges[u, v]['weight']
                    sig = v  
        G.nodes[sig]['π'] = u
        _dfs(G, sig, cam, sig)
            


def dfs(G, s):
    camino = []
    sig = s
    for u in G.nodes:
        G.nodes[u]['visited'] = False
        G.nodes[u]['π'] = -1
    _dfs(G, s, camino, sig)
    print(f"El camino es el siguiente {camino}")

"""PATH CON DFS"""

dfs(G,1)
path = [0]*G.number_of_nodes()
for v, info in G.nodes.data():
  path[v] = info['π']
gs.nx2gv(G, path=path, weighted=True, params={'size':'20'})

"""3.   BFS

"""

def menor(G,s):
  z = []
  for i in G.neighbors(s):
    x = G.edges[s,i]['weight']
    z.append(x)
    z.sort()
  return min(z)
def bfscamino(G, s):
  P = G.copy()
  H = G.copy()
  queue = [s]
  camino = [s]
  costo = []
  for u in P.nodes:
    P.nodes[u]['visited'] = False
    P.nodes[u]['π'] = -1
  P.nodes[s]['visited'] = True
  while queue:
    s = camino[0]
    u = queue[0]
    for v in P.neighbors(u):
      if not P.nodes[v]['visited'] and H.edges[s,v]['weight'] == menor(H,s):
        costo.append(menor(H,s))
        P.nodes[v]['visited'] = True
        P.nodes[v]['π'] = u
        camino.append(v)
        queue.append(v)
    if len(H) >= 2:
       H.remove_node(queue[1])
    del queue[0]
  costototal = sum(costo)
  return camino,costototal
def bfs(G,s):
  queue = [s]
  for u in G.nodes:
    G.nodes[u]['visited'] = False
    G.nodes[u]['π'] = -1
  G.nodes[s]['visited'] = True
  while queue:
    u = queue[0]

    for v in G.neighbors(u):
      if not G.nodes[v]['visited']:
        G.nodes[v]['visited'] = True
        G.nodes[v]['π'] = u
        queue.append(v)

    del queue[0]
    

def bfstotal(G,s):
  x = bfscamino(G,s)[0]
  y = bfscamino(G,s)[1]
  bfs(G,s)
  print("El camino es:", x)
  print("El costo por el camino es:",y)

"""PATH CON BFS"""

bfstotal(G,0)
path = [0]*G.number_of_nodes()
for v, info in G.nodes.data():
  path[int(v)] = int(info['π'])
#print(path)
#gs.path2gv(path)
gs.nx2gv(G, path=path, weighted=True, params={'size':'20'})

"""4. BRUTEFORCE"""

def menor(G,s):
  z = []
  for i in G.neighbors(s):
    x = G.edges[s,i]['weight']
    z.append(x)
    z.sort()
  return min(z)
  
def bruteforce(G, s):
  P = nx.Graph(G)
  L = nx.Graph(G)
  x = []
  queue = [s]
  camino = [s]
  for u in G.nodes:
    G.nodes[u]['visited'] = False
    G.nodes[u]['path'] = -1
  G.nodes[s]['visited'] = True
  while queue:
    u = queue[0]
    for v in G.neighbors(u):
      if not G.nodes[v]['visited'] and L.edges[u,v]['weight'] == menor(L,u):
        x.append(menor(L,u))
        G.nodes[v]['visited'] = True
        G.nodes[v]['path'] = u
        camino.append(v)
        queue.append(v)
    L.remove_node(queue[0])
    del queue[0]
  costo =sum(x)
  return camino, costo

"""PATH CON BRUTEFORCE"""

road = bruteforce(G,0)[0]
cost = bruteforce(G,0)[1]
print("El camino a seguir es: ",road)
print("El costo por este camino es: ",cost)

path = [0]*G.number_of_nodes()
for v, info in G.nodes.data():
  path[int(v)] = int(info['path'])
#print(path)
gs.path2gv(path)
#gs.nx2gv(G, path=path, weighted=True, params={'size':'20'})
#G.nodes.data()

G.nodes.data()

